#!/usr/bin/env python3
"""
üîÆ Telegram AI Predictor - FreqTrade Multi-Strategy
Sistema de IA preditiva integrado ao Telegram
"""

import os
import asyncio
import json
import logging
import random
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
from telegram import Update
from telegram.ext import ContextTypes

# Configura√ß√£o
VALID_PAIRS = [
    "BTC/USDT", "ETH/USDT", "BNB/USDT", "ADA/USDT", "DOT/USDT",
    "LINK/USDT", "LTC/USDT", "BCH/USDT", "XRP/USDT", "EOS/USDT"
]

STRATEGIES = {
    "stratA": "Sample Strategy A",
    "stratB": "Sample Strategy B", 
    "waveHyperNW": "WaveHyperNW Strategy",
    "mlStrategy": "ML Strategy",
    "mlStrategySimple": "ML Strategy Simple",
    "multiTimeframe": "Multi Timeframe Strategy",
    "waveEnhanced": "WaveHyperNW Enhanced"
}

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class AIPredictor:
    """Sistema de IA preditiva para an√°lise de mercado"""
    
    def __init__(self):
        self.confidence_threshold = 65.0
        self.prediction_cache = {}
        self.last_analysis = None
    
    def _generate_technical_analysis(self, pair: str) -> Dict:
        """Gerar an√°lise t√©cnica simulada (em produ√ß√£o, usaria dados reais)"""
        # Simular indicadores t√©cnicos
        rsi = random.uniform(20, 80)
        macd_signal = random.choice(["bullish", "bearish", "neutral"])
        bb_position = random.choice(["upper", "middle", "lower"])
        volume_trend = random.choice(["increasing", "decreasing", "stable"])
        
        # Simular padr√µes de candlestick
        patterns = ["doji", "hammer", "shooting_star", "engulfing", "none"]
        candlestick_pattern = random.choice(patterns)
        
        # Simular n√≠veis de suporte e resist√™ncia
        current_price = random.uniform(20000, 70000) if pair == "BTC/USDT" else random.uniform(1000, 4000)
        support = current_price * random.uniform(0.95, 0.98)
        resistance = current_price * random.uniform(1.02, 1.05)
        
        return {
            "pair": pair,
            "current_price": current_price,
            "rsi": rsi,
            "macd_signal": macd_signal,
            "bollinger_position": bb_position,
            "volume_trend": volume_trend,
            "candlestick_pattern": candlestick_pattern,
            "support_level": support,
            "resistance_level": resistance,
            "timestamp": datetime.now()
        }
    
    def _calculate_prediction_confidence(self, analysis: Dict) -> Tuple[str, float, str]:
        """Calcular previs√£o e n√≠vel de confian√ßa"""
        score = 50.0  # Base neutra
        
        # An√°lise RSI
        rsi = analysis["rsi"]
        if rsi < 30:
            score += 15  # Oversold - bullish
        elif rsi > 70:
            score -= 15  # Overbought - bearish
        elif 40 <= rsi <= 60:
            score += 5   # Neutral zone - slight bullish
        
        # An√°lise MACD
        macd = analysis["macd_signal"]
        if macd == "bullish":
            score += 12
        elif macd == "bearish":
            score -= 12
        
        # An√°lise Bollinger Bands
        bb = analysis["bollinger_position"]
        if bb == "lower":
            score += 8   # Near lower band - bullish
        elif bb == "upper":
            score -= 8   # Near upper band - bearish
        
        # An√°lise de Volume
        volume = analysis["volume_trend"]
        if volume == "increasing":
            score += 6
        elif volume == "decreasing":
            score -= 3
        
        # Padr√µes de Candlestick
        pattern = analysis["candlestick_pattern"]
        pattern_scores = {
            "hammer": 10,
            "engulfing": 8,
            "doji": 0,
            "shooting_star": -8,
            "none": 0
        }
        score += pattern_scores.get(pattern, 0)
        
        # Adicionar ru√≠do aleat√≥rio para simular complexidade real
        noise = random.uniform(-5, 5)
        score += noise
        
        # Garantir que est√° no range 0-100
        confidence = max(0, min(100, score))
        
        # Determinar dire√ß√£o
        if confidence >= 55:
            direction = "ALTA"
            reason = self._generate_bullish_reason(analysis)
        elif confidence <= 45:
            direction = "BAIXA" 
            reason = self._generate_bearish_reason(analysis)
        else:
            direction = "LATERAL"
            reason = "Sinais mistos, mercado indeciso"
        
        return direction, confidence, reason
    
    def _generate_bullish_reason(self, analysis: Dict) -> str:
        """Gerar raz√£o para previs√£o de alta"""
        reasons = []
        
        if analysis["rsi"] < 35:
            reasons.append("RSI em oversold")
        if analysis["macd_signal"] == "bullish":
            reasons.append("MACD bullish")
        if analysis["bollinger_position"] == "lower":
            reasons.append("Pre√ßo pr√≥ximo √† banda inferior")
        if analysis["volume_trend"] == "increasing":
            reasons.append("Volume crescente")
        if analysis["candlestick_pattern"] in ["hammer", "engulfing"]:
            reasons.append(f"Padr√£o {analysis['candlestick_pattern']} bullish")
        
        if not reasons:
            reasons = ["Momentum t√©cnico positivo", "Conflu√™ncia de indicadores"]
        
        return ", ".join(reasons[:3])  # M√°ximo 3 raz√µes
    
    def _generate_bearish_reason(self, analysis: Dict) -> str:
        """Gerar raz√£o para previs√£o de baixa"""
        reasons = []
        
        if analysis["rsi"] > 65:
            reasons.append("RSI em overbought")
        if analysis["macd_signal"] == "bearish":
            reasons.append("MACD bearish")
        if analysis["bollinger_position"] == "upper":
            reasons.append("Pre√ßo pr√≥ximo √† banda superior")
        if analysis["volume_trend"] == "decreasing":
            reasons.append("Volume decrescente")
        if analysis["candlestick_pattern"] == "shooting_star":
            reasons.append("Padr√£o shooting star bearish")
        
        if not reasons:
            reasons = ["Press√£o vendedora", "Sinais de corre√ß√£o"]
        
        return ", ".join(reasons[:3])  # M√°ximo 3 raz√µes
    
    async def predict_pair(self, pair: str) -> Dict:
        """Fazer previs√£o para um par espec√≠fico"""
        logger.info(f"üîÆ Gerando previs√£o para {pair}")
        
        if pair not in VALID_PAIRS:
            return {
                "success": False,
                "error": f"Par {pair} n√£o est√° na whitelist"
            }
        
        # Gerar an√°lise t√©cnica
        analysis = self._generate_technical_analysis(pair)
        
        # Calcular previs√£o
        direction, confidence, reason = self._calculate_prediction_confidence(analysis)
        
        # Gerar timeframe de previs√£o
        timeframes = ["1-2 horas", "2-4 horas", "4-8 horas", "8-12 horas"]
        timeframe = random.choice(timeframes)
        
        # Calcular target de pre√ßo
        current_price = analysis["current_price"]
        if direction == "ALTA":
            price_change = random.uniform(1.5, 8.0)
            target_price = current_price * (1 + price_change/100)
        elif direction == "BAIXA":
            price_change = random.uniform(-8.0, -1.5)
            target_price = current_price * (1 + price_change/100)
        else:
            price_change = random.uniform(-2.0, 2.0)
            target_price = current_price * (1 + price_change/100)
        
        return {
            "success": True,
            "pair": pair,
            "direction": direction,
            "confidence": confidence,
            "reason": reason,
            "timeframe": timeframe,
            "current_price": current_price,
            "target_price": target_price,
            "price_change": abs(price_change),
            "analysis": analysis,
            "timestamp": datetime.now()
        }
    
    async def predict_all_pairs(self) -> Dict:
        """Fazer previs√µes para todos os pares"""
        logger.info("üîÆ Gerando previs√µes para todos os pares")
        
        predictions = {}
        opportunities = []
        
        for pair in VALID_PAIRS:
            prediction = await self.predict_pair(pair)
            if prediction["success"]:
                predictions[pair] = prediction
                
                # Identificar oportunidades (alta confian√ßa)
                if prediction["confidence"] >= self.confidence_threshold:
                    opportunities.append(prediction)
        
        # Ordenar oportunidades por confian√ßa
        opportunities.sort(key=lambda x: x["confidence"], reverse=True)
        
        return {
            "success": True,
            "predictions": predictions,
            "opportunities": opportunities[:5],  # Top 5
            "total_pairs": len(VALID_PAIRS),
            "high_confidence_count": len(opportunities),
            "timestamp": datetime.now()
        }
    
    async def analyze_strategy_opportunities(self, strategy: str) -> Dict:
        """Analisar oportunidades espec√≠ficas para uma estrat√©gia"""
        logger.info(f"üîÆ Analisando oportunidades para {strategy}")
        
        if strategy not in STRATEGIES:
            return {
                "success": False,
                "error": f"Estrat√©gia {strategy} n√£o encontrada"
            }
        
        # Obter previs√µes de todos os pares
        all_predictions = await self.predict_all_pairs()
        
        if not all_predictions["success"]:
            return all_predictions
        
        # Filtrar oportunidades baseado no perfil da estrat√©gia
        strategy_profiles = {
            "stratA": {"min_confidence": 60, "preferred_direction": "ALTA", "timeframe_pref": "short"},
            "stratB": {"min_confidence": 65, "preferred_direction": "ALTA", "timeframe_pref": "short"},
            "waveHyperNW": {"min_confidence": 70, "preferred_direction": "any", "timeframe_pref": "very_short"},
            "mlStrategy": {"min_confidence": 75, "preferred_direction": "any", "timeframe_pref": "medium"},
            "mlStrategySimple": {"min_confidence": 65, "preferred_direction": "ALTA", "timeframe_pref": "medium"},
            "multiTimeframe": {"min_confidence": 70, "preferred_direction": "any", "timeframe_pref": "long"},
            "waveEnhanced": {"min_confidence": 72, "preferred_direction": "any", "timeframe_pref": "short"}
        }
        
        profile = strategy_profiles.get(strategy, {"min_confidence": 65, "preferred_direction": "any"})
        
        # Filtrar previs√µes baseado no perfil
        suitable_opportunities = []
        
        for prediction in all_predictions["opportunities"]:
            if prediction["confidence"] >= profile["min_confidence"]:
                if profile["preferred_direction"] == "any" or prediction["direction"] == profile["preferred_direction"]:
                    suitable_opportunities.append(prediction)
        
        return {
            "success": True,
            "strategy": strategy,
            "strategy_name": STRATEGIES[strategy],
            "profile": profile,
            "opportunities": suitable_opportunities[:3],  # Top 3 para a estrat√©gia
            "total_opportunities": len(suitable_opportunities),
            "timestamp": datetime.now()
        }

# Inst√¢ncia global
ai_predictor = AIPredictor()

# ============================================================================
# HANDLERS PARA COMANDOS TELEGRAM
# ============================================================================

async def predict_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando /predict [pair]"""
    args = context.args
    
    await update.message.reply_text("üîÆ Analisando mercado com IA...")
    
    if args:
        # Previs√£o para par espec√≠fico
        pair = args[0].upper()
        result = await ai_predictor.predict_pair(pair)
        
        if result["success"]:
            direction_emoji = "üü¢" if result["direction"] == "ALTA" else "üî¥" if result["direction"] == "BAIXA" else "üü°"
            confidence_emoji = "üî•" if result["confidence"] >= 80 else "‚úÖ" if result["confidence"] >= 65 else "‚ö†Ô∏è"
            
            message = f"""üîÆ <b>PREVIS√ÉO IA - {result['pair']}</b>

{direction_emoji} <b>Dire√ß√£o:</b> {result['direction']}
{confidence_emoji} <b>Confian√ßa:</b> {result['confidence']:.1f}%
‚è∞ <b>Timeframe:</b> {result['timeframe']}

üí∞ <b>Pre√ßo Atual:</b> ${result['current_price']:,.2f}
üéØ <b>Target:</b> ${result['target_price']:,.2f}
üìä <b>Varia√ß√£o:</b> {result['price_change']:.1f}%

üß† <b>An√°lise:</b>
{result['reason']}

üìà <b>Indicadores:</b>
‚Ä¢ RSI: {result['analysis']['rsi']:.1f}
‚Ä¢ MACD: {result['analysis']['macd_signal']}
‚Ä¢ Bollinger: {result['analysis']['bollinger_position']}
‚Ä¢ Volume: {result['analysis']['volume_trend']}

‚ö†Ô∏è <b>Aviso:</b> Previs√µes s√£o baseadas em an√°lise t√©cnica e n√£o garantem resultados."""
            
            await update.message.reply_text(message, parse_mode='HTML')
        else:
            await update.message.reply_text(result["error"])
    
    else:
        # Previs√µes r√°pidas para todos os pares
        result = await ai_predictor.predict_all_pairs()
        
        if result["success"]:
            message = "üîÆ <b>PREVIS√ïES R√ÅPIDAS - IA</b>\n\n"
            
            # Mostrar top oportunidades
            if result["opportunities"]:
                message += "üî• <b>TOP OPORTUNIDADES:</b>\n"
                for i, opp in enumerate(result["opportunities"][:3], 1):
                    direction_emoji = "üü¢" if opp["direction"] == "ALTA" else "üî¥" if opp["direction"] == "BAIXA" else "üü°"
                    message += f"{i}. {direction_emoji} {opp['pair']} - {opp['confidence']:.0f}% ({opp['direction']})\n"
                message += "\n"
            
            # Resumo geral
            message += f"üìä <b>RESUMO:</b>\n"
            message += f"‚Ä¢ Pares Analisados: {result['total_pairs']}\n"
            message += f"‚Ä¢ Alta Confian√ßa: {result['high_confidence_count']}\n"
            message += f"‚Ä¢ Timestamp: {result['timestamp'].strftime('%H:%M:%S')}\n\n"
            
            message += "üí° Use /predict <PAR> para an√°lise detalhada"
            
            await update.message.reply_text(message, parse_mode='HTML')
        else:
            await update.message.reply_text("‚ùå Erro ao gerar previs√µes")

async def ai_analysis_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando /ai_analysis [strategy]"""
    args = context.args
    
    await update.message.reply_text("üß† Executando an√°lise completa com IA...")
    
    if args:
        # An√°lise para estrat√©gia espec√≠fica
        strategy = args[0]
        result = await ai_predictor.analyze_strategy_opportunities(strategy)
        
        if result["success"]:
            message = f"""üß† <b>AN√ÅLISE IA - {result['strategy_name']}</b>

‚öôÔ∏è <b>Perfil da Estrat√©gia:</b>
‚Ä¢ Confian√ßa M√≠nima: {result['profile']['min_confidence']}%
‚Ä¢ Dire√ß√£o Preferida: {result['profile']['preferred_direction']}

üéØ <b>Oportunidades Identificadas:</b> {result['total_opportunities']}

"""
            
            if result["opportunities"]:
                message += "üî• <b>TOP OPORTUNIDADES:</b>\n"
                for i, opp in enumerate(result["opportunities"], 1):
                    direction_emoji = "üü¢" if opp["direction"] == "ALTA" else "üî¥"
                    message += f"""
{i}. {direction_emoji} <b>{opp['pair']}</b>
   Confian√ßa: {opp['confidence']:.1f}%
   Target: ${opp['target_price']:,.2f} ({opp['price_change']:.1f}%)
   Raz√£o: {opp['reason'][:50]}...
"""
            else:
                message += "‚ö†Ô∏è Nenhuma oportunidade de alta confian√ßa encontrada no momento."
            
            message += f"\n‚è∞ An√°lise: {result['timestamp'].strftime('%H:%M:%S')}"
            
            await update.message.reply_text(message, parse_mode='HTML')
        else:
            await update.message.reply_text(result["error"])
    
    else:
        # An√°lise geral do mercado
        result = await ai_predictor.predict_all_pairs()
        
        if result["success"]:
            # An√°lise de sentimento geral
            bullish_count = sum(1 for p in result["predictions"].values() if p["direction"] == "ALTA")
            bearish_count = sum(1 for p in result["predictions"].values() if p["direction"] == "BAIXA")
            neutral_count = len(result["predictions"]) - bullish_count - bearish_count
            
            avg_confidence = sum(p["confidence"] for p in result["predictions"].values()) / len(result["predictions"])
            
            if bullish_count > bearish_count:
                market_sentiment = "üü¢ BULLISH"
            elif bearish_count > bullish_count:
                market_sentiment = "üî¥ BEARISH"
            else:
                market_sentiment = "üü° NEUTRO"
            
            message = f"""üß† <b>AN√ÅLISE COMPLETA DO MERCADO</b>

üìä <b>Sentimento Geral:</b> {market_sentiment}

üìà <b>Distribui√ß√£o:</b>
‚Ä¢ Alta: {bullish_count} pares ({bullish_count/len(result['predictions'])*100:.0f}%)
‚Ä¢ Baixa: {bearish_count} pares ({bearish_count/len(result['predictions'])*100:.0f}%)
‚Ä¢ Lateral: {neutral_count} pares ({neutral_count/len(result['predictions'])*100:.0f}%)

üéØ <b>Confian√ßa M√©dia:</b> {avg_confidence:.1f}%
üî• <b>Oportunidades:</b> {len(result['opportunities'])}

"""
            
            if result["opportunities"]:
                message += "<b>üöÄ MELHORES OPORTUNIDADES:</b>\n"
                for i, opp in enumerate(result["opportunities"][:5], 1):
                    direction_emoji = "üü¢" if opp["direction"] == "ALTA" else "üî¥"
                    message += f"{i}. {direction_emoji} {opp['pair']} ({opp['confidence']:.0f}%)\n"
            
            message += f"\n‚è∞ An√°lise: {result['timestamp'].strftime('%H:%M:%S')}"
            message += "\n\nüí° Use /ai_analysis <strategy> para an√°lise espec√≠fica"
            
            await update.message.reply_text(message, parse_mode='HTML')
        else:
            await update.message.reply_text("‚ùå Erro ao executar an√°lise completa")

async def opportunities_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando /opportunities - Mostrar oportunidades de alta confian√ßa"""
    await update.message.reply_text("üîç Identificando oportunidades de alta confian√ßa...")
    
    result = await ai_predictor.predict_all_pairs()
    
    if result["success"] and result["opportunities"]:
        message = "üî• <b>OPORTUNIDADES DE ALTA CONFIAN√áA</b>\n\n"
        
        for i, opp in enumerate(result["opportunities"], 1):
            direction_emoji = "üü¢" if opp["direction"] == "ALTA" else "üî¥" if opp["direction"] == "BAIXA" else "üü°"
            confidence_emoji = "üî•" if opp["confidence"] >= 80 else "‚úÖ"
            
            message += f"""{i}. {direction_emoji} <b>{opp['pair']}</b>
   {confidence_emoji} Confian√ßa: {opp['confidence']:.1f}%
   üéØ Target: ${opp['target_price']:,.2f}
   üìä Varia√ß√£o: {opp['price_change']:.1f}%
   ‚è∞ Timeframe: {opp['timeframe']}
   üí° {opp['reason'][:60]}...

"""
        
        message += f"üìä Total: {len(result['opportunities'])} oportunidades identificadas"
        message += f"\n‚è∞ An√°lise: {result['timestamp'].strftime('%H:%M:%S')}"
        
        await update.message.reply_text(message, parse_mode='HTML')
    else:
        await update.message.reply_text("‚ö†Ô∏è Nenhuma oportunidade de alta confian√ßa encontrada no momento.\n\nTente novamente em alguns minutos.")

# ============================================================================
# FUN√á√ïES AUXILIARES
# ============================================================================

def format_prediction_summary(predictions: Dict) -> str:
    """Formatar resumo de previs√µes"""
    if not predictions:
        return "Nenhuma previs√£o dispon√≠vel"
    
    bullish = sum(1 for p in predictions.values() if p["direction"] == "ALTA")
    bearish = sum(1 for p in predictions.values() if p["direction"] == "BAIXA")
    neutral = len(predictions) - bullish - bearish
    
    return f"üìä Alta: {bullish} | Baixa: {bearish} | Lateral: {neutral}"